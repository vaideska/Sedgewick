/* 20042019>>TKUZNETSOVA

Примеры решения задачи связности:
Имеется последовательность пар цел чисел p-q (p связанно с q). Предполагается, что отношение "связано с" транзитивное:
если p-r, а q-r, то p-r. Задача состоит в том, чобы исключить лишние пары из набора: программа выводит пару только в том случае,
если она не является связной. Если в соответсвии с ранее просмотренными парами следует, что пара связана, то программа игнорирует
ввод и переходит к вводу следующей паре.

Задача решается с помощью абстракных операций поиска и объединения. После считывания пары мы производим поиск
для каждого члена пары. Если они находятся в одном множестве, то переходим к новой паре.
Если нет, то объединяем множества и сохраняем пару.
*/

#include <iostream>
using namespace std;

static const int N = 10;

/* Решение задачи методом быстрого поиска.
Алгоритм выполняет не менее MN инструкций для решения задачи связности при наличии N объектов,
для которых требуется выполнение M операций объединений.
*/
void QuickSearch(int* id);
void QuickUnion(int* id);

int main()
{
    int i, id[N];
    for (i = 0; i < N; i++) id[i] = i;  //Члены массива id равны, когда объекты p и q - связаны.

    //QuickSearch(id);                    //Быстрый поиск
    QuickUnion(id);                       //Быстрое объединение
    
}

/* Решение задачи методом быстрого поиска.
Алгоритм выполняет не менее MN инструкций для решения задачи связности при наличии N объектов,
для которых требуется выполнение M операций объединений.
*/
void QuickSearch(int* id)
{
    int i, p, q;
    while (cin >> p >> q)
    {
        int t = id[p];
        if (t == id[q]) continue;           //пара находится в одном множестве
        for (i = 0; i < N; i++)             //поиск множества, где находится объект p
            if (id[i] == t) id[i] = id[q];  //объединение множества p с множеством q

        cout << " " << p << " " << q << endl;
        for (i = 0; i < N; i++) cout << id[i] << " ";
        cout << endl;
    }
    return;
}


/* Решение задачи методом быстрого объединения.
Для M пар из N объектов, когда M > N, решение данным алгоритмом может потребовать выплнения более чем MN/2 инструкций.
*/
void QuickUnion(int* id)
{
    int i, j, p, q;
    while (cin >> p >> q)
    {
        for (i = p; i != id[i]; i = id[i]);     //если массв представить в виде дерева - тут идет поиск корня
        for (j = q; j != id[j]; j = id[j]);     //для объектов p и q. id[x] - ссылка на следующий элемент множества.
        if (i == j) continue;                   //"корень" один, значит объекты в одном множестве, иначе:
        id[i] = j;                              //происходит объединение

        cout << " " << p << " " << q << endl;
        for (i = 0; i < N; i++) cout << i << " ";
        cout << endl;
        for (i = 0; i < N; i++) cout << id[i] << " ";
        cout << endl;
    }
    return;
}